import numpy as np
import cv2
from tqdm import tqdm
import matplotlib.pyplot as plt

class VisualOdometry:
    def __init__(self, dataset_path, calib_path, poses_path, num_images=1000):
        self.images = self.load_images(dataset_path, num_images)
        self.K, self.P = self.load_calibration(calib_path)
        self.gt_poses = self.load_poses(poses_path, num_images)
        self.orb = cv2.ORB_create()
        self.flann = cv2.FlannBasedMatcher(indexParams=self.get_flann_index_params(), searchParams=self.get_flann_search_params())

    def load_images(self, path, num_images):
        images = []
        for i in range(num_images):
            img_path = f"{path}/{str(i).zfill(6)}.png"
            img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
            images.append(img)
        return images

    def load_calibration(self, calib_path):
        with open(calib_path, 'r') as f:
            lines = f.readlines()

        P0 = np.array([line.strip().split(' ')[1:] for line in lines[0:4]], dtype=np.float32)
        K = P0[0:3, 0:3]
        return K, P0

    def load_poses(self, poses_path, num_poses):
        poses = []
        with open(poses_path, 'r') as f:
            lines = f.readlines()

        for i in range(num_poses):
            pose = np.array([float(x) for x in lines[i].strip().split(' ')[1:]])
            poses.append(pose)

        return np.array(poses)

    def get_flann_index_params(self):
        FLANN_INDEX_LSH = 6
        return dict(algorithm=FLANN_INDEX_LSH, table_number=6, key_size=12, multi_probe_level=1)

    def get_flann_search_params(self):
        return dict(checks=50)

    def detect_and_describe_features(self, image):
        keypoints, descriptors = self.orb.detectAndCompute(image, None)
        return keypoints, descriptors

    def match_features(self, descriptors1, descriptors2, keypoints1, keypoints2):
        bf = cv2.BFMatcher(cv2.NORM_HAMMING)
        matches = bf.knnMatch(descriptors1, descriptors2, k=2)
        
        good_matches = []
        for m, n in matches:
            if m.distance < 0.75 * n.distance:
                good_matches.append(m)
        
        src_pts = np.float32([keypoints1[m.queryIdx].pt for m in good_matches]).reshape(-1, 1, 2)
        dst_pts = np.float32([keypoints2[m.trainIdx].pt for m in good_matches]).reshape(-1, 1, 2)
        
        E, mask = cv2.findEssentialMat(src_pts, dst_pts, self.K, method=cv2.RANSAC, prob=0.999, threshold=1.0)
        _, R, t, mask = cv2.recoverPose(E, src_pts, dst_pts, self.K)
        
        good_matches = [m for m, msk in zip(good_matches, mask) if msk[0] == 1]
        
        return good_matches, R, t

    def decompose_essential_matrix(self, E):
        _, R1, t1, _, _ = cv2.decomposeEssentialMat(E)
        _, R2, t2, _, _ = cv2.decomposeEssentialMat(E)
        
        return R1, t1, R2, t2

    def run_visual_odometry(self):
        trajectory = [np.zeros(3),]
        R = np.eye(3)
        t = np.zeros((3, 1))

        for i in tqdm(range(1, len(self.images))):
            keypoints1, descriptors1 = self.detect_and_describe_features(self.images[i-1])
            keypoints2, descriptors2 = self.detect_and_describe_features(self.images[i])

            matches, R_delta, t_delta = self.match_features(descriptors1, descriptors2, keypoints1, keypoints2)

            R = np.dot(R, R_delta)
            t = t + np.dot(R, t_delta)
            
            trajectory.append(t.flatten())

        return np.array(trajectory)

if __name__ == "__main__":
    dataset_path = r'C:/Users/sharm/OneDrive/Desktop/SDC/dataset/sequences/00/image_0/'
    calib_path = r'C:\Users\sharm\OneDrive\Desktop\SDC\dataset\sequences\00\calib.txt'
    poses_path = r'C:\Users\sharm\OneDrive\Desktop\SDC\poses\00.txt'
    
    vo = VisualOdometry(dataset_path, calib_path, poses_path)
    trajectory = vo.run_visual_odometry()

    # Plot trajectory
    plt.figure()
    plt.plot(trajectory[:, 0], trajectory[:, 2], label='Estimated')
    plt.plot(vo.gt_poses[:, 3], -vo.gt_poses[:, 10], label='Ground Truth')
    plt.title('Visual Odometry Trajectory')
    plt.xlabel('x')
    plt.ylabel('z')
    plt.legend()
    plt.show()
